// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: usages.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getPlansUsageForOwner = `-- name: GetPlansUsageForOwner :many
WITH category_sums AS (
    SELECT
        plan_id,
        SUM(withdrawl) AS total_withdrawl,
        SUM(deposit) AS total_deposit
    FROM plan_categories
    GROUP BY plan_id
),
line_item_sums AS (
    SELECT
        plan_categories.plan_id,
        SUM(line_items.withdrawl) AS total_withdrawl,
        SUM(line_items.deposit) AS total_deposit
    FROM line_items 
    JOIN plan_categories ON plan_categories.id = line_items.plan_category_id
    GROUP BY plan_categories.plan_id
)
SELECT
    plans.id AS plan_id,
    COALESCE(category_sums.total_withdrawl, 0)::BIGINT AS target_withdrawl_amount,
    COALESCE(category_sums.total_deposit, 0)::BIGINT AS target_deposit_amount,
    COALESCE(line_item_sums.total_withdrawl, 0)::BIGINT AS actual_withdrawl_amount,
    COALESCE(line_item_sums.total_deposit, 0)::BIGINT AS actual_deposit_amount
FROM plans
LEFT JOIN category_sums ON category_sums.plan_id = plans.id
LEFT JOIN line_item_sums ON line_item_sums.plan_id = plans.id
WHERE plans.owner_id = $1
  AND plans.name ILIKE '%' || $4 || '%'
ORDER BY plans.name
LIMIT $2 OFFSET $3
`

type GetPlansUsageForOwnerParams struct {
	OwnerID uuid.UUID
	Limit   int32
	Offset  int32
	Keyword sql.NullString
}

type GetPlansUsageForOwnerRow struct {
	PlanID                uuid.UUID
	TargetWithdrawlAmount int64
	TargetDepositAmount   int64
	ActualWithdrawlAmount int64
	ActualDepositAmount   int64
}

func (q *Queries) GetPlansUsageForOwner(ctx context.Context, arg GetPlansUsageForOwnerParams) ([]GetPlansUsageForOwnerRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlansUsageForOwner,
		arg.OwnerID,
		arg.Limit,
		arg.Offset,
		arg.Keyword,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlansUsageForOwnerRow
	for rows.Next() {
		var i GetPlansUsageForOwnerRow
		if err := rows.Scan(
			&i.PlanID,
			&i.TargetWithdrawlAmount,
			&i.TargetDepositAmount,
			&i.ActualWithdrawlAmount,
			&i.ActualDepositAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
